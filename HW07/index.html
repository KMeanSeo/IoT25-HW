<!DOCTYPE html>
<html>
  <head>
    <title>ESP32 RSSI Monitor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        line-height: 1.6;
      }
      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #333;
        text-align: center;
      }
      .data-container {
        background-color: #f5f5f5;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        transition: background-color 0.3s;
      }
      .data-update {
        background-color: #e3f2fd;
      }
      .value {
        font-size: 24px;
        font-weight: bold;
        color: #2c3e50;
      }
      .chart-container {
        height: 300px;
        margin: 20px 0;
      }
      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 5px;
      }
      button#disconnectBleButton {
        background-color: #f44336;
      }
      button#clearChartButton {
        background-color: #ff9800;
      }
      button#forceReadButton {
        background-color: #2196f3;
      }
      button#addMeasurementButton {
        background-color: #9c27b0;
      }
      .status {
        margin-top: 10px;
      }
      .error-message {
        color: #f44336;
        font-weight: bold;
        margin: 10px 0;
      }
      .chart-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .chart-time-selector {
        display: flex;
        gap: 10px;
      }
      .time-button {
        background-color: #607d8b;
        padding: 5px 10px;
        font-size: 14px;
      }
      .time-button.active {
        background-color: #2196f3;
      }
      .data-log {
        max-height: 150px;
        overflow-y: auto;
        border: 1px solid #ddd;
        padding: 10px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
      }
      .debug-info {
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        padding: 10px;
        margin-top: 10px;
        font-family: monospace;
        font-size: 12px;
      }
      .connection-mode {
        margin-top: 10px;
        padding: 10px;
        background-color: #fff3cd;
        border-radius: 5px;
      }
      .mode-selector {
        display: flex;
        gap: 10px;
        margin-top: 5px;
      }
      .model-params {
        background-color: #e8f5e9;
        padding: 15px;
        border-radius: 5px;
        margin: 15px 0;
      }
      .param-input {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .param-input label {
        width: 200px;
      }
      .param-input input {
        width: 80px;
        padding: 5px;
        margin-right: 10px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
      }
      th {
        background-color: #f2f2f2;
      }
      tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      .measurement-input {
        display: flex;
        align-items: center;
        margin: 15px 0;
        gap: 10px;
      }
      .measurement-input input {
        padding: 8px;
        width: 100px;
      }
      #colorIndicator {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        margin: 10px auto;
        border: 1px solid #ddd;
        transition: background-color 0.5s;
      }
      .rgb-controls {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
      }
      .rgb-slider {
        display: flex;
        flex-direction: column;
        width: 30%;
      }
      .rgb-slider input {
        margin: 5px 0;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.1/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0/dist/chartjs-adapter-luxon.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>ESP32 RSSI and Distance Monitor</h1>

      <div class="status">
        <button id="connectBleButton">Connect to ESP32</button>
        <button id="disconnectBleButton">Disconnect</button>
        <p>
          BLE Status:
          <strong
            ><span id="bleState" style="color: #d13a30"
              >Not Connected</span
            ></strong
          >
        </p>
        <p id="bleError" class="error-message" style="display: none">
          Web Bluetooth API is not available in this browser. Please use Chrome,
          Edge, or Opera.
        </p>
      </div>

      <div class="connection-mode">
        <p>Data Receiving Mode:</p>
        <div class="mode-selector">
          <label
            ><input type="radio" name="mode" value="notification" checked />
            Notification Mode</label
          >
          <label
            ><input type="radio" name="mode" value="polling" /> Polling
            Mode</label
          >
        </div>
        <p id="modeDescription">
          Using notification mode: Device will send data automatically when
          available.
        </p>
      </div>

      <div class="data-container" id="rssiContainer">
        <h2>RSSI Value</h2>
        <p class="value" id="rssiValue">--</p>
        <p>Last Update: <span id="rssiTimestamp">--</span></p>
      </div>

      <div class="data-container" id="txPowerContainer">
        <h2>TX Power Value</h2>
        <p class="value" id="txPowerValue">--</p>
      </div>

      <div class="data-container" id="distanceContainer">
        <h2>Estimated Distance</h2>
        <p class="value" id="distanceValue">--</p>
        <p>
          Based on path loss model: distance = 10<sup
            >(txPower - RSSI)/(10*n)</sup
          >
        </p>
      </div>

      <div class="data-container" id="rgbContainer">
        <h2>RGB LED Status</h2>
        <div id="colorIndicator"></div>
        <p id="colorName">Not set</p>
        <p>Color changes automatically based on distance:</p>
        <ul>
          <li>â‰¥ 4m: White (255,255,255)</li>
          <li>3-4m: Green (0,255,0)</li>
          <li>2-3m: Yellow (255,255,0)</li>
          <li>1-2m: Orange (255,165,0)</li>
          <li>&lt;1m: Red (255,0,0)</li>
        </ul>
        <div class="rgb-controls">
          <div class="rgb-slider">
            <label for="redSlider">Red: <span id="redValue">0</span></label>
            <input type="range" id="redSlider" min="0" max="255" value="0" />
          </div>
          <div class="rgb-slider">
            <label for="greenSlider"
              >Green: <span id="greenValue">0</span></label
            >
            <input type="range" id="greenSlider" min="0" max="255" value="0" />
          </div>
          <div class="rgb-slider">
            <label for="blueSlider">Blue: <span id="blueValue">0</span></label>
            <input type="range" id="blueSlider" min="0" max="255" value="0" />
          </div>
        </div>
        <button id="sendRgbButton">Send Custom RGB</button>
        <button id="toggleAutoRgbButton">Auto RGB: ON</button>
      </div>

      <div class="model-params">
        <h3>Distance Estimation Model Parameters</h3>
        <div class="param-input">
          <label for="pathLossExponent">Path Loss Exponent (n):</label>
          <input
            type="number"
            id="pathLossExponent"
            value="2.0"
            step="0.1"
            min="1.0"
            max="4.0"
          />
          <span>Range: 1.0 (free space) to 4.0 (indoor with obstacles)</span>
        </div>
        <div class="param-input">
          <label for="referenceDistance">Reference Distance (m):</label>
          <input
            type="number"
            id="referenceDistance"
            value="1.0"
            step="0.1"
            min="0.1"
          />
        </div>
        <button id="updateModelButton">Update Model</button>
      </div>

      <div class="chart-controls">
        <div class="chart-time-selector">
          <button class="time-button active" data-time="1">1 Min</button>
          <button class="time-button" data-time="5">5 Min</button>
          <button class="time-button" data-time="15">15 Min</button>
          <button class="time-button" data-time="30">30 Min</button>
        </div>
        <button id="clearChartButton">Clear Chart</button>
      </div>

      <div class="chart-container">
        <canvas id="rssiChart"></canvas>
      </div>

      <div class="chart-container">
        <canvas id="distanceChart"></canvas>
      </div>

      <h3>Distance Measurement Analysis</h3>
      <div class="measurement-input">
        <label for="actualDistance">Actual Distance (m):</label>
        <input
          type="number"
          id="actualDistance"
          value="1.0"
          step="0.1"
          min="0.1"
        />
        <button id="addMeasurementButton">Add Measurement</button>
      </div>

      <table id="measurementTable">
        <thead>
          <tr>
            <th>Actual Distance (m)</th>
            <th>Measured Distance (m)</th>
            <th>Error (m)</th>
            <th>Error (%)</th>
            <th>RSSI (dBm)</th>
            <th>TX Power (dBm)</th>
          </tr>
        </thead>
        <tbody>
          <!-- Measurement data will be added here -->
        </tbody>
      </table>

      <div class="chart-container">
        <canvas id="comparisonChart"></canvas>
      </div>

      <p>Target ESP32 MAC Address: <span id="macAddress">--</span></p>
      <p>Connection Time: <span id="connectionTime">--</span></p>
      <p>Device Name: <span id="deviceName">ESP32_RSSI_Server</span></p>

      <h3>Debugging Information</h3>
      <div class="debug-info">
        <p>Notification Count: <span id="notificationCount">0</span></p>
        <p>
          Last Notification Time: <span id="lastNotificationTime">Never</span>
        </p>
        <p>
          Connection Status: <span id="connectionStatus">Disconnected</span>
        </p>
        <button id="forceReadButton">Force Read Value</button>
        <p>Browser Info: <span id="browserInfo">--</span></p>
      </div>

      <h3>Data Log</h3>
      <div class="data-log" id="dataLog"></div>
    </div>

    <script>
        // DOM Elements
        const connectButton = document.getElementById("connectBleButton");
        const disconnectButton = document.getElementById("disconnectBleButton");
        const clearChartButton = document.getElementById("clearChartButton");
        const forceReadButton = document.getElementById("forceReadButton");
        const updateModelButton = document.getElementById("updateModelButton");
        const addMeasurementButton = document.getElementById(
          "addMeasurementButton"
        );
        const sendRgbButton = document.getElementById("sendRgbButton");
        const toggleAutoRgbButton = document.getElementById(
          "toggleAutoRgbButton"
        );
        const rssiValueElement = document.getElementById("rssiValue");
        const txPowerValueElement = document.getElementById("txPowerValue");
        const distanceValueElement = document.getElementById("distanceValue");
        const bleStateContainer = document.getElementById("bleState");
        const rssiTimestampElement = document.getElementById("rssiTimestamp");
        const macAddressElement = document.getElementById("macAddress");
        const connectionTimeElement = document.getElementById("connectionTime");
        const deviceNameElement = document.getElementById("deviceName");
        const bleErrorElement = document.getElementById("bleError");
        const dataLogElement = document.getElementById("dataLog");
        const rssiContainer = document.getElementById("rssiContainer");
        const txPowerContainer = document.getElementById("txPowerContainer");
        const distanceContainer = document.getElementById("distanceContainer");
        const rgbContainer = document.getElementById("rgbContainer");
        const colorIndicator = document.getElementById("colorIndicator");
        const colorName = document.getElementById("colorName");
        const timeButtons = document.querySelectorAll(".time-button");
        const notificationCountElement =
          document.getElementById("notificationCount");
        const lastNotificationTimeElement = document.getElementById(
          "lastNotificationTime"
        );
        const connectionStatusElement =
          document.getElementById("connectionStatus");
        const browserInfoElement = document.getElementById("browserInfo");
        const modeRadios = document.querySelectorAll('input[name="mode"]');
        const modeDescriptionElement = document.getElementById("modeDescription");
        const pathLossExponentInput = document.getElementById("pathLossExponent");
        const referenceDistanceInput =
          document.getElementById("referenceDistance");
        const actualDistanceInput = document.getElementById("actualDistance");
        const measurementTableBody = document
          .getElementById("measurementTable")
          .querySelector("tbody");
        const redSlider = document.getElementById("redSlider");
        const greenSlider = document.getElementById("greenSlider");
        const blueSlider = document.getElementById("blueSlider");
        const redValue = document.getElementById("redValue");
        const greenValue = document.getElementById("greenValue");
        const blueValue = document.getElementById("blueValue");

        // Define BLE Device Specs
        const deviceName = "ESP32_RSSI_Server";
        const bleService = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
        const dataCharacteristic = "beb5483e-36e1-4688-b7f5-ea07361b26a8";

        // Global Variables to Handle Bluetooth
        let bleServer;
        let bleServiceFound;
        let dataCharacteristicFound;
        let connectionStartTime;
        let chartTimeWindow = 1; // Default time window in minutes
        let notificationCount = 0;
        let pollingInterval;
        let reconnectAttempts = 0;
        let usePollingMode = false;
        let autoRgbEnabled = true;

        // Distance model parameters
        let pathLossExponent = 2.0;
        let referenceDistance = 1.0;

        // Current values
        let currentRssi = null;
        let currentTxPower = null;
        let currentDistance = null;
        let currentRgb = { r: 0, g: 0, b: 0 };

        // Measurement data for analysis
        const measurements = [];

        // Data for charts
        const rssiData = {
          datasets: [
            {
              label: "RSSI (dBm)",
              data: [],
              borderColor: "rgb(75, 192, 192)",
              backgroundColor: "rgba(75, 192, 192, 0.2)",
              borderWidth: 2,
              tension: 0.2,
              pointRadius: 3,
            },
          ],
        };

        const distanceData = {
          datasets: [
            {
              label: "Distance (m)",
              data: [],
              borderColor: "rgb(255, 99, 132)",
              backgroundColor: "rgba(255, 99, 132, 0.2)",
              borderWidth: 2,
              tension: 0.2,
              pointRadius: 3,
            },
          ],
        };

        // Chart configurations
        const rssiChartConfig = {
          type: "line",
          data: rssiData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 300,
            },
            scales: {
              x: {
                type: "time",
                time: {
                  unit: "second",
                  displayFormats: {
                    second: "HH:mm:ss",
                  },
                  tooltipFormat: "HH:mm:ss",
                },
                title: {
                  display: true,
                  text: "Time",
                },
              },
              y: {
                suggestedMin: -100,
                suggestedMax: -30,
                title: {
                  display: true,
                  text: "RSSI (dBm)",
                },
              },
            },
            plugins: {
              legend: {
                position: "top",
              },
              tooltip: {
                callbacks: {
                  title: function (tooltipItems) {
                    return luxon.DateTime.fromMillis(
                      tooltipItems[0].parsed.x
                    ).toFormat("HH:mm:ss");
                  },
                },
              },
            },
          },
        };

        const distanceChartConfig = {
          type: "line",
          data: distanceData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 300,
            },
            scales: {
              x: {
                type: "time",
                time: {
                  unit: "second",
                  displayFormats: {
                    second: "HH:mm:ss",
                  },
                  tooltipFormat: "HH:mm:ss",
                },
                title: {
                  display: true,
                  text: "Time",
                },
              },
              y: {
                suggestedMin: 0,
                suggestedMax: 5,
                title: {
                  display: true,
                  text: "Distance (m)",
                },
              },
            },
            plugins: {
              legend: {
                position: "top",
              },
              tooltip: {
                callbacks: {
                  title: function (tooltipItems) {
                    return luxon.DateTime.fromMillis(
                      tooltipItems[0].parsed.x
                    ).toFormat("HH:mm:ss");
                  },
                },
              },
            },
          },
        };

        const comparisonChartConfig = {
          type: "bar",
          data: {
            labels: [],
            datasets: [
              {
                label: "Actual Distance (m)",
                data: [],
                backgroundColor: "rgba(54, 162, 235, 0.5)",
                borderColor: "rgb(54, 162, 235)",
                borderWidth: 1,
              },
              {
                label: "Measured Distance (m)",
                data: [],
                backgroundColor: "rgba(255, 99, 132, 0.5)",
                borderColor: "rgb(255, 99, 132)",
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Distance (m)",
                },
              },
              x: {
                title: {
                  display: true,
                  text: "Measurement",
                },
              },
            },
          },
        };

        // Initialize charts
        let rssiChart = new Chart(
          document.getElementById("rssiChart"),
          rssiChartConfig
        );

        let distanceChart = new Chart(
          document.getElementById("distanceChart"),
          distanceChartConfig
        );

        let comparisonChart = new Chart(
          document.getElementById("comparisonChart"),
          comparisonChartConfig
        );

        // Connect Button
        connectButton.addEventListener("click", (event) => {
          if (isWebBluetoothEnabled()) {
            connectToDevice();
          }
        });

        // Disconnect Button
        disconnectButton.addEventListener("click", disconnectDevice);

        // Clear Chart Button
        clearChartButton.addEventListener("click", () => {
          rssiData.datasets[0].data = [];
          distanceData.datasets[0].data = [];
          rssiChart.update();
          distanceChart.update();
          addLogMessage("Charts cleared");
        });

        // Force Read Button
        forceReadButton.addEventListener("click", async () => {
          if (dataCharacteristicFound && bleServer && bleServer.connected) {
            try {
              addLogMessage("Forcing value read...");
              const value = await dataCharacteristicFound.readValue();
              const decodedValue = new TextDecoder().decode(value);
              addLogMessage(`Forced read value: ${decodedValue}`);
              processReceivedData(decodedValue);
            } catch (error) {
              addLogMessage(`Force read error: ${error.message}`);
            }
          } else {
            addLogMessage("Cannot force read: not connected");
          }
        });

        // Update Model Button
        updateModelButton.addEventListener("click", () => {
          pathLossExponent = parseFloat(pathLossExponentInput.value);
          referenceDistance = parseFloat(referenceDistanceInput.value);

          addLogMessage(
            `Model parameters updated: n=${pathLossExponent}, d0=${referenceDistance}m`
          );

          // Recalculate current distance if we have RSSI and TX Power
          if (currentRssi !== null && currentTxPower !== null) {
            currentDistance = calculateDistance(currentRssi, currentTxPower);
            distanceValueElement.textContent = currentDistance.toFixed(2) + " m";
            highlightContainer(distanceContainer);

            // Update RGB if auto mode is enabled
            if (autoRgbEnabled) {
              updateRGBBasedOnDistance(currentDistance);
            }
          }
        });

        // Add Measurement Button
        addMeasurementButton.addEventListener("click", () => {
          const actualDistance = parseFloat(actualDistanceInput.value);

          if (isNaN(actualDistance) || actualDistance <= 0) {
            alert("Please enter a valid actual distance");
            return;
          }

          if (currentDistance === null) {
            alert("No current distance measurement available");
            return;
          }

          // Add measurement to the array
          const measurement = {
            actualDistance: actualDistance,
            measuredDistance: currentDistance,
            error: Math.abs(currentDistance - actualDistance),
            errorPercent: Math.abs(
              ((currentDistance - actualDistance) / actualDistance) * 100
            ),
            rssi: currentRssi,
            txPower: currentTxPower,
            timestamp: new Date(),
          };

          measurements.push(measurement);

          // Add to table
          addMeasurementToTable(measurement);

          // Update comparison chart
          updateComparisonChart();

          addLogMessage(
            `Measurement added: Actual=${actualDistance}m, Measured=${currentDistance.toFixed(
              2
            )}m`
          );
        });

        // Send RGB Button
        sendRgbButton.addEventListener("click", () => {
          const r = parseInt(redSlider.value);
          const g = parseInt(greenSlider.value);
          const b = parseInt(blueSlider.value);

          sendRgbValues(r, g, b);
        });

        // Toggle Auto RGB Button
        toggleAutoRgbButton.addEventListener("click", () => {
          autoRgbEnabled = !autoRgbEnabled;
          toggleAutoRgbButton.textContent = `Auto RGB: ${
            autoRgbEnabled ? "ON" : "OFF"
          }`;

          if (autoRgbEnabled && currentDistance !== null) {
            // Update RGB based on current distance
            updateRGBBasedOnDistance(currentDistance);
          }

          addLogMessage(
            `Auto RGB mode: ${autoRgbEnabled ? "Enabled" : "Disabled"}`
          );
        });

        // RGB Sliders
        redSlider.addEventListener("input", updateColorPreview);
        greenSlider.addEventListener("input", updateColorPreview);
        blueSlider.addEventListener("input", updateColorPreview);

        function updateColorPreview() {
          const r = parseInt(redSlider.value);
          const g = parseInt(greenSlider.value);
          const b = parseInt(blueSlider.value);

          redValue.textContent = r;
          greenValue.textContent = g;
          blueValue.textContent = b;

          colorIndicator.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          colorName.textContent = `Custom RGB(${r}, ${g}, ${b})`;
        }

        // Time window selector buttons
        timeButtons.forEach((button) => {
          button.addEventListener("click", (e) => {
            // Remove active class from all buttons
            timeButtons.forEach((btn) => btn.classList.remove("active"));
            // Add active class to clicked button
            e.target.classList.add("active");
            // Update time window
            chartTimeWindow = parseInt(e.target.dataset.time);
            addLogMessage(
              `Chart time window set to ${chartTimeWindow} minute(s)`
            );
            // Update chart
            updateChartTimeWindow();
          });
        });

        // Mode radio buttons
        modeRadios.forEach((radio) => {
          radio.addEventListener("change", (e) => {
            usePollingMode = e.target.value === "polling";
            if (usePollingMode) {
              modeDescriptionElement.textContent =
                "Using polling mode: Data will be requested every second.";
              addLogMessage("Switched to polling mode");
            } else {
              modeDescriptionElement.textContent =
                "Using notification mode: Device will send data automatically when available.";
              addLogMessage("Switched to notification mode");
            }

            // If already connected, update the connection mode
            if (bleServer && bleServer.connected && dataCharacteristicFound) {
              updateConnectionMode();
            }
          });
        });

        // Check if BLE is available in your Browser
        function isWebBluetoothEnabled() {
          if (!navigator.bluetooth) {
            console.log("Web Bluetooth API is not available in this browser!");
            bleErrorElement.style.display = "block";
            return false;
          }
          console.log("Web Bluetooth API supported in this browser.");
          bleErrorElement.style.display = "none";
          return true;
        }

        // Check browser compatibility
        function checkBrowserCompatibility() {
          const userAgent = navigator.userAgent;
          const isAndroid = /Android/i.test(userAgent);
          const isChrome = /Chrome/i.test(userAgent);
          const chromeVersion = userAgent.match(/Chrome\/(\d+)/);

          const browserInfo = {
            userAgent,
            isAndroid,
            isChrome,
            chromeVersion: chromeVersion ? chromeVersion[1] : "unknown",
          };

          console.log("Browser environment:", browserInfo);
          browserInfoElement.textContent = `${
            isAndroid ? "Android" : "Desktop"
          } with ${
            isChrome
              ? "Chrome " + (chromeVersion ? chromeVersion[1] : "unknown")
              : "Other browser"
          }`;

          addLogMessage(
            `Running on ${isAndroid ? "Android" : "Desktop"} with ${
              isChrome
                ? "Chrome " + (chromeVersion ? chromeVersion[1] : "unknown")
                : "Other browser"
            }`
          );

          // Android Chrome often has issues with notifications
          if (isAndroid && isChrome) {
            addLogMessage(
              "Android Chrome detected - consider using polling mode"
            );
            document.querySelector('input[value="polling"]').checked = true;
            usePollingMode = true;
            modeDescriptionElement.textContent =
              "Using polling mode: Data will be requested every second.";
          }

          return browserInfo;
        }

        // Connect to BLE Device and Enable Notifications
        async function connectToDevice() {
          console.log("Initializing Bluetooth...");
          addLogMessage("Initializing Bluetooth connection...");

          try {
            const device = await navigator.bluetooth.requestDevice({
              filters: [{ name: deviceName }],
              optionalServices: [bleService],
            });

            console.log("Device Selected:", device.name);
            addLogMessage(`Device selected: ${device.name}`);
            deviceNameElement.textContent = device.name || deviceName;
            macAddressElement.textContent = device.id || "Unknown";
            bleStateContainer.innerHTML = "Connected to " + device.name;
            bleStateContainer.style.color = "#24af37";
            connectionStatusElement.textContent = "Connected";

            device.addEventListener("gattservicedisconnected", onDisconnected);
            connectionStartTime = new Date();
            updateConnectionTime();

            // Connect to GATT server
            bleServer = await device.gatt.connect();
            console.log("Connected to GATT Server");
            addLogMessage("Connected to GATT Server");

            // Get service
            bleServiceFound = await bleServer.getPrimaryService(bleService);
            console.log("Service discovered:", bleServiceFound.uuid);
            addLogMessage(`Service discovered: ${bleServiceFound.uuid}`);

            // Get characteristic
            dataCharacteristicFound = await bleServiceFound.getCharacteristic(
              dataCharacteristic
            );
            console.log(
              "Characteristic discovered:",
              dataCharacteristicFound.uuid
            );
            addLogMessage(
              `Characteristic discovered: ${dataCharacteristicFound.uuid}`
            );

            // Set up connection based on selected mode
            await updateConnectionMode();

            // Initial read
            const value = await dataCharacteristicFound.readValue();
            const decodedValue = new TextDecoder().decode(value);
            console.log("Initial value:", decodedValue);
            addLogMessage(`Initial value: ${decodedValue}`);
            processReceivedData(decodedValue);

            // Start connection monitoring
            monitorConnection();

            // Reset reconnect attempts
            reconnectAttempts = 0;
          } catch (error) {
            console.log("Connection error:", error);
            addLogMessage(`Connection error: ${error.message}`);
            bleStateContainer.innerHTML = "Connection Error: " + error.message;
            bleStateContainer.style.color = "#d13a30";
            connectionStatusElement.textContent = "Connection Failed";
          }
        }

        // Update connection mode based on user selection
        async function updateConnectionMode() {
          if (!dataCharacteristicFound || !bleServer || !bleServer.connected) {
            addLogMessage("Cannot update connection mode: not connected");
            return;
          }

          // Clear existing polling interval
          if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
          }

          try {
            // Stop notifications if they were started
            await dataCharacteristicFound.stopNotifications();
            addLogMessage("Notifications stopped for mode change");
          } catch (e) {
            console.log("Error stopping notifications:", e);
          }

          if (usePollingMode) {
            // Set up polling interval
            addLogMessage("Starting polling mode");
            pollingInterval = setInterval(async () => {
              if (bleServer && bleServer.connected && dataCharacteristicFound) {
                try {
                  const value = await dataCharacteristicFound.readValue();
                  const decodedValue = new TextDecoder().decode(value);
                  console.log("Polled value:", decodedValue);
                  processReceivedData(decodedValue);
                } catch (error) {
                  console.error("Polling error:", error);
                  addLogMessage(`Polling error: ${error.message}`);
                }
              }
            }, 1000); // Poll every second
          } else {
            // Set up notifications
            addLogMessage("Starting notification mode");
            dataCharacteristicFound.addEventListener(
              "characteristicvaluechanged",
              handleCharacteristicChange
            );
            await dataCharacteristicFound.startNotifications();
            console.log("Notifications started");
            addLogMessage("Notifications started");
          }
        }

        function onDisconnected(event) {
          console.log("Device Disconnected:", event.target.device.name);
          addLogMessage(`Device disconnected: ${event.target.device.name}`);
          bleStateContainer.innerHTML = "Device Disconnected";
          bleStateContainer.style.color = "#d13a30";
          connectionTimeElement.textContent = "--";
          connectionStatusElement.textContent = "Disconnected";

          // Clear polling interval if active
          if (pollingInterval) {
      scanTask,    // Task function
          }
        }

        function handleCharacteristicChange(event) {
          try {
            const newValueReceived = new TextDecoder().decode(event.target.value);
            console.log("Characteristic value changed:", newValueReceived);

            // Update notification count and time
            notificationCount++;
            notificationCountElement.textContent = notificationCount;
            const now = new Date();
            lastNotificationTimeElement.textContent = now.toLocaleTimeString();

            // Process the data
            processReceivedData(newValueReceived);
          } catch (error) {
            console.error("Error handling notification:", error);
            addLogMessage(`Error handling notification: ${error.message}`);
          }
        }

        function processReceivedData(dataString) {
          // Expected format: "RSSI:-75,TXPower:9"
          try {
            if (dataString.includes("RSSI:")) {
              const rssiMatch = dataString.match(/RSSI:(-?\d+)/);
              if (rssiMatch && rssiMatch[1]) {
                const rssiValue = parseInt(rssiMatch[1]);
                currentRssi = rssiValue;
                rssiValueElement.textContent = rssiValue + " dBm";

                // Highlight the container to show new data
                highlightContainer(rssiContainer);

                // Add data point to chart
                addRssiDataPoint(rssiValue);

                // Log the data
                addLogMessage(`RSSI: ${rssiValue} dBm`);
              }

              const txPowerMatch = dataString.match(/TXPower:(-?\d+)/);
              if (txPowerMatch && txPowerMatch[1]) {
                const txPowerValue = parseInt(txPowerMatch[1]);
                currentTxPower = txPowerValue;
                txPowerValueElement.textContent = txPowerValue + " dBm";

                // Highlight the container to show new data
                highlightContainer(txPowerContainer);

                // Log the data
                addLogMessage(`TX Power: ${txPowerValue} dBm`);
              } else {
                txPowerValueElement.textContent = "No information";
              }

              // Calculate distance if we have both RSSI and TX Power
              if (currentRssi !== null && currentTxPower !== null) {
                currentDistance = calculateDistance(currentRssi, currentTxPower);
                distanceValueElement.textContent =
                  currentDistance.toFixed(2) + " m";

                // Highlight the container to show new data
                highlightContainer(distanceContainer);

                // Add data point to distance chart
                addDistanceDataPoint(currentDistance);

                // Log the data
                addLogMessage(
                  `Estimated Distance: ${currentDistance.toFixed(2)} m`
                );

                // Update RGB if auto mode is enabled
                if (autoRgbEnabled) {
                  updateRGBBasedOnDistance(currentDistance);
                }
              }

              const now = getDateTime();
              rssiTimestampElement.textContent = now;
            } else if (dataString.includes("Heartbeat:")) {
              // Handle heartbeat message
              addLogMessage(`Heartbeat received: ${dataString}`);
            }
          } catch (error) {
            console.error("Data processing error:", error);
            addLogMessage(`Data processing error: ${error.message}`);
          }
        }

        // Calculate distance using path loss model
        function calculateDistance(rssi, txPower) {
          // Path loss model: distance = 10^((txPower - RSSI)/(10*n))
          //const exponent = (txPower - rssi) / (10 * pathLossExponent);
          return Math.pow(10, (txPower - rssi - 69.09) / 31.73);
        }

        // Update RGB LEDs based on distance thresholds
        function updateRGBBasedOnDistance(distance) {
          let r, g, b;
          let colorText;

          // Set RGB values based on distance thresholds
          if (distance >= 4.0) {
            // White for 4m+
            r = 255;
            g = 255;
            b = 255;
            colorText = "White (â‰¥ 4m)";
          } else if (distance >= 3.0) {
            // Green for 3-4m
            r = 0;
            g = 255;
            b = 0;
            colorText = "Green (3-4m)";
          } else if (distance >= 2.0) {
            // Yellow for 2-3m
            r = 255;
            g = 255;
            b = 0;
            colorText = "Yellow (2-3m)";
          } else if (distance >= 1.0) {
            // Orange for 1-2m
            r = 255;
            g = 165;
            b = 0;
            colorText = "Orange (1-2m)";
          } else {
            // Red for <1m
            r = 255;
            g = 0;
            b = 0;
            colorText = "Red (<1m)";
          }

          // Update sliders to match
          redSlider.value = r;
          greenSlider.value = g;
          blueSlider.value = b;
          redValue.textContent = r;
          greenValue.textContent = g;
          blueValue.textContent = b;

          // Update color indicator
          colorIndicator.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          colorName.textContent = colorText;

          // Send RGB values to ESP32
          sendRgbValues(r, g, b);
        }

        // Send RGB values to ESP32
        function sendRgbValues(r, g, b) {
          if (!dataCharacteristicFound || !bleServer || !bleServer.connected) {
            addLogMessage("Cannot send RGB: not connected");
            return;
          }

          // Store current RGB values
          currentRgb = { r, g, b };

          // Create command string for RGB
          const rgbCommand = `RGB:${r},${g},${b}`;

          // Send RGB command to ESP32
          try {
            const encoder = new TextEncoder();
            const rgbData = encoder.encode(rgbCommand);

            dataCharacteristicFound
              .writeValue(rgbData)
              .then(() => {
                console.log(`RGB values sent: R=${r}, G=${g}, B=${b}`);
                addLogMessage(`RGB values sent: R=${r}, G=${g}, B=${b}`);
              })
              .catch((error) => {
                console.error("Error sending RGB values:", error);
                addLogMessage(`Error sending RGB: ${error.message}`);
              });
          } catch (error) {
            console.error("Error preparing RGB data:", error);
            addLogMessage(`Error preparing RGB data: ${error.message}`);
          }
        }

        function addRssiDataPoint(rssiValue) {
          const now = new Date();

          // Add new data point
          rssiData.datasets[0].data.push({
            x: now,
            y: rssiValue,
          });

          // Update chart time window
          updateChartTimeWindow();

          // Update chart
          rssiChart.update();
        }

        function addDistanceDataPoint(distanceValue) {
          const now = new Date();

          // Add new data point
          distanceData.datasets[0].data.push({
            x: now,
            y: distanceValue,
          });

          // Update chart time window
          updateChartTimeWindow();

          // Update chart
          distanceChart.update();
        }

        function updateChartTimeWindow() {
          // Calculate time window
          const now = new Date();
          const minTime = new Date(now.getTime() - chartTimeWindow * 60 * 1000); // Convert minutes to milliseconds

          // Remove data points outside the time window for RSSI chart
          rssiData.datasets[0].data = rssiData.datasets[0].data.filter(
            (point) => point.x >= minTime
          );

          // Remove data points outside the time window for distance chart
          distanceData.datasets[0].data = distanceData.datasets[0].data.filter(
            (point) => point.x >= minTime
          );

          // Update RSSI chart x-axis
          rssiChart.options.scales.x.min = minTime;
          rssiChart.options.scales.x.max = now;

          // Update distance chart x-axis
          distanceChart.options.scales.x.min = minTime;
          distanceChart.options.scales.x.max = now;

          // Update charts
          rssiChart.update();
          distanceChart.update();
        }

        function addMeasurementToTable(measurement) {
          const row = document.createElement("tr");

          row.innerHTML = `
          <td>${measurement.actualDistance.toFixed(2)}</td>
          <td>${measurement.measuredDistance.toFixed(2)}</td>
          <td>${measurement.error.toFixed(2)}</td>
          <td>${measurement.errorPercent.toFixed(2)}%</td>
          <td>${measurement.rssi}</td>
          <td>${measurement.txPower}</td>
        `;

          measurementTableBody.appendChild(row);
        }

        function updateComparisonChart() {
          // Clear existing data
          comparisonChart.data.labels = [];
          comparisonChart.data.datasets[0].data = [];
          comparisonChart.data.datasets[1].data = [];

          // Add labels and data for each measurement
          measurements.forEach((measurement, index) => {
            comparisonChart.data.labels.push(`#${index + 1}`);
            comparisonChart.data.datasets[0].data.push(
              measurement.actualDistance
            );
            comparisonChart.data.datasets[1].data.push(
              measurement.measuredDistance
            );
          });

          // Update chart
          comparisonChart.update();
        }

        function highlightContainer(container) {
          // Add highlight class
          container.classList.add("data-update");

          // Remove highlight class after animation
          setTimeout(() => {
            container.classList.remove("data-update");
          }, 500);
        }

        function disconnectDevice() {
          console.log("Disconnect Device.");
          addLogMessage("Disconnecting device...");

          // Clear polling interval if active
          if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
          }

          if (bleServer && bleServer.connected) {
            if (dataCharacteristicFound) {
              dataCharacteristicFound
                .stopNotifications()
                .then(() => {
                  console.log("Notifications Stopped");
                  addLogMessage("Notifications stopped");
                  return bleServer.disconnect();
                })
                .then(() => {
                  console.log("Device Disconnected");
                  addLogMessage("Device disconnected successfully");
                  bleStateContainer.innerHTML = "Device Disconnected";
                  bleStateContainer.style.color = "#d13a30";
                  connectionTimeElement.textContent = "--";
                  connectionStatusElement.textContent = "Disconnected";
                })
                .catch((error) => {
                  console.log("An error occurred:", error);
                  addLogMessage(`Disconnect error: ${error.message}`);
                });
            } else {
              console.log("No characteristic found to disconnect.");
              addLogMessage("No characteristic found to disconnect");
            }
          } else {
            console.error("Bluetooth is not connected.");
            addLogMessage("Bluetooth is not connected");
            window.alert("Bluetooth is not connected.");
          }
        }

        function getDateTime() {
          const currentdate = new Date();
          const day = ("00" + currentdate.getDate()).slice(-2);
          const month = ("00" + (currentdate.getMonth() + 1)).slice(-2);
          const year = currentdate.getFullYear();
          const hours = ("00" + currentdate.getHours()).slice(-2);
          const minutes = ("00" + currentdate.getMinutes()).slice(-2);
          const seconds = ("00" + currentdate.getSeconds()).slice(-2);
          const milliseconds = ("000" + currentdate.getMilliseconds()).slice(-3);

          const datetime =
            year +
            "-" +
            month +
            "-" +
            day +
            " " +
            hours +
            ":" +
            minutes +
            ":" +
            seconds +
            "." +
            milliseconds;
          return datetime;
        }

        function updateConnectionTime() {
          if (connectionStartTime) {
            const now = new Date();
            const diff = Math.floor((now - connectionStartTime) / 1000);
            const minutes = Math.floor(diff / 60);
            const seconds = diff % 60;
            connectionTimeElement.textContent =
              minutes + " min " + seconds + " sec";

            if (bleServer && bleServer.connected) {
              setTimeout(updateConnectionTime, 1000);
            }
          }
        }

        function addLogMessage(message) {
          const timestamp = getDateTime();
          const logEntry = document.createElement("div");
          logEntry.textContent = `[${timestamp.split(" ")[1]}] ${message}`;
          dataLogElement.appendChild(logEntry);

          // Scroll to bottom
          dataLogElement.scrollTop = dataLogElement.scrollHeight;

          // Limit log entries
          while (dataLogElement.childElementCount > 100) {
            dataLogElement.removeChild(dataLogElement.firstChild);
          }
        }

        // Monitor connection status
        function monitorConnection() {
          if (bleServer) {
            const isConnected = bleServer.connected;
            connectionStatusElement.textContent = isConnected
              ? "Connected"
              : "Disconnected";

            // If we think we're connected but haven't received notifications in a while
            if (isConnected && !usePollingMode) {
              const now = new Date();
              const lastNotificationTime =
                lastNotificationTimeElement.textContent;
              if (lastNotificationTime !== "Never") {
                const lastTime = new Date(
                  `${now.toDateString()} ${lastNotificationTime}`
                );
                const timeSinceLastNotification = (now - lastTime) / 1000;

                // If no notifications for 10 seconds, try to restart notifications
                if (timeSinceLastNotification > 10) {
                  addLogMessage(
                    `No notifications for ${Math.round(
                      timeSinceLastNotification
                    )} seconds, restarting...`
                  );
                  restartNotifications();
                }
              }
            }
          }

          // Check again in 5 seconds
          setTimeout(monitorConnection, 5000);
        }

        // Restart notifications
        async function restartNotifications() {
          if (
            dataCharacteristicFound &&
            bleServer &&
            bleServer.connected &&
            !usePollingMode
          ) {
            try {
              // Stop existing notifications
              await dataCharacteristicFound.stopNotifications();
              addLogMessage("Notifications stopped for restart");

              // Start notifications again
              await dataCharacteristicFound.startNotifications();
              addLogMessage("Notifications restarted");
            } catch (error) {
              console.error("Error restarting notifications:", error);
              addLogMessage(`Error restarting notifications: ${error.message}`);
            }
          }
        }

        // Reconnect to device
        async function reconnect(device) {
          try {
            addLogMessage("Attempting to reconnect...");

            // Try to connect to GATT server
            bleServer = await device.gatt.connect();
            console.log("Reconnected to GATT Server");
            addLogMessage("Reconnected to GATT Server");

            // Get service
            bleServiceFound = await bleServer.getPrimaryService(bleService);
            console.log("Service rediscovered");

            // Get characteristic
            dataCharacteristicFound = await bleServiceFound.getCharacteristic(
              dataCharacteristic
            );
            console.log("Characteristic rediscovered");

            // Set up connection based on selected mode
            await updateConnectionMode();

            // Update UI
            bleStateContainer.innerHTML = "Reconnected to " + device.name;
            bleStateContainer.style.color = "#24af37";
            connectionStatusElement.textContent = "Connected";

            // Reset reconnect attempts
            reconnectAttempts = 0;
          } catch (error) {
            console.error("Reconnection failed:", error);
            addLogMessage(`Reconnection failed: ${error.message}`);

            // Update UI
            bleStateContainer.innerHTML = "Reconnection Failed";
            bleStateContainer.style.color = "#d13a30";
            connectionStatusElement.textContent = "Disconnected";
          }
        }

        // Execute on page load
        document.addEventListener("DOMContentLoaded", function () {
          console.log("Page loaded, ready for BLE connection");
          addLogMessage("Page loaded, ready for BLE connection");
          isWebBluetoothEnabled();
          checkBrowserCompatibility();

          // Initialize model parameters
          pathLossExponent = parseFloat(pathLossExponentInput.value);
          referenceDistance = parseFloat(referenceDistanceInput.value);

          // Initialize color preview
          updateColorPreview();
        });
    </script>
  </body>
</html>
